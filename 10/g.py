import sys
import heapq

# Устанавливаем высокий лимит рекурсии, хотя для итеративного алгоритма Дейкстры это не требуется.
# Строка закомментирована, так как в данном случае глубокая рекурсия не используется.
# sys.setrecursionlimit(2000)

# Функция для выполнения алгоритма Дейкстры.
# Находит кратчайшие пути от заданной стартовой вершины до всех остальных вершин в графе.
# Принимает:
# start_node: индекс стартовой вершины (в 0-базовой индексации).
# n: общее количество вершин в графе.
# adj: список смежности графа. adj[u] содержит список кортежей (v, weight) для всех соседей v вершины u
# с весом ребра weight.
# Возвращает список кратчайших расстояний от start_node до всех вершин.
def dijkstra(start_node, n, adj):
    """
    Реализация алгоритма Дейкстры для поиска кратчайших путей от start_node
    до всех остальных вершин в графе с неотрицательными весами ребер.
    Возвращает список кратчайших расстояний (время в данном случае).
    """
    # Инициализируем список расстояний. dist[i] будет хранить текущее кратчайшее
    # расстояние, найденное до вершины с индексом i.
    # Изначально все расстояния устанавливаются в "бесконечность" (очень большое значение),
    # кроме расстояния от стартовой вершины до самой себя, которое равно 0.
    dist = [float('inf')] * n
    dist[start_node] = 0

    # Создаем приоритетную очередь (минимальную кучу). Используем модуль heapq.
    # В очереди храним кортежи вида (текущее_кратчайшее_расстояние, индекс_вершины).
    # Элементы автоматически упорядочиваются по первому элементу кортежа (расстоянию),
    # и heappop() извлекает элемент с наименьшим значением расстояния.
    pq = [(0, start_node)] # Добавляем стартовую вершину в очередь с расстоянием 0.

    # Основной цикл алгоритма Дейкстры. Выполняется до тех пор, пока приоритетная очередь не опустеет.
    while pq:
        # Извлекаем вершину u с наименьшим текущим расстоянием d из приоритетной очереди.
        # heapq.heappop(pq) извлекает и возвращает наименьший элемент.
        d, u = heapq.heappop(pq) # d - текущее расстояние до вершины u, u - индекс вершины.

        # Проверяем, является ли извлеченная запись устаревшей. Если расстояние d, с которым
        # мы извлекли вершину u, больше, чем текущее кратчайшее расстояние, которое уже записано
        # для вершины u в списке dist[u], это означает, что мы нашли более короткий путь к u ранее
        # и обновили dist[u]. Эту устаревшую запись из очереди можно проигнорировать.
        if d > dist[u]:
            continue

        # Перебираем всех соседей v текущей вершины u. Для каждого соседа получаем вес ребра w.
        for v, weight in adj[u]:
            # Выполняем операцию "релаксации" для ребра (u, v).
            # Проверяем, можно ли найти более короткий путь до вершины v, пройдя через вершину u.
            # Расстояние до v через u равно сумме текущего кратчайшего расстояния до u (dist[u])
            # и веса ребра (u, v) (weight).
            if dist[u] + weight < dist[v]:
                # Если найден более короткий путь до вершины v, обновляем кратчайшее расстояние до v.
                dist[v] = dist[u] + weight
                # Добавляем вершину v в приоритетную очередь с новым, меньшим расстоянием.
                # heapq.heappush(pq, (dist[v], v)) добавит новый элемент в кучу. Если вершина v
                # уже была в очереди с большим расстоянием, новая запись с меньшим расстоянием
                # будет обработана раньше.
                heapq.heappush(pq, (dist[v], v))

    # По завершении цикла возвращаем список кратчайших расстояний от стартовой вершины
    # до всех остальных вершин.
    return dist

# Определяем основную функцию solve(), которая решает задачу поиска минимального времени
# для посещения домиков a, b и c.
def solve():
    # Читаем первую строку входных данных: количество вершин (n) и количество ребер (m).
    n, m = map(int, sys.stdin.readline().split())

    # Создаем список смежности графа. adj[i] - это список кортежей (сосед_индекс, вес_ребра).
    # Используем 0-базовую индексацию для вершин (от 0 до n-1) для удобства работы со списками в Python.
    adj = [[] for _ in range(n)]

    # Читаем описания ребер. Каждое ребро задается начальной вершиной (u), конечной вершиной (v)
    # и весом (w - время прохождения).
    for _ in range(m):
        u, v, w = map(int, sys.stdin.readline().split())
        # Преобразуем номера вершин из 1-базовой индексации (из входных данных) в 0-базовую.
        u -= 1
        v -= 1
        # Поскольку граф неориентированный, добавляем информацию о ребре в списки смежности обеих вершин.
        adj[u].append((v, w))
        adj[v].append((u, w))

    # Читаем индексы целевых домиков a, b, c (в 1-базовой индексации).
    # По условию, a, b, c попарно различны.
    a, b, c = map(int, sys.stdin.readline().split())
    # Преобразуем номера вершин в 0-базовые индексы для работы с графом.
    a -= 1
    b -= 1
    c -= 1

    # Чтобы найти минимальное время для посещения всех трех вершин a, b и c, мы можем рассмотреть
    # три основных варианта пути, составленных из кратчайших путей между парами этих вершин.
    # Путь, посещающий a, b, c, должен эффективно "покрыть" два кратчайших пути, соединяющих
    # эти три точки. Три таких комбинации кратчайших путей:
    # 1. Кратчайший путь из a в b, затем кратчайший путь из b в c. Общее время = d(a, b) + d(b, c).
    # 2. Кратчайший путь из a в c, затем кратчайший путь из c в b. Общее время = d(a, c) + d(c, b).
    # 3. Кратчайший путь из b в a, затем кратчайший путь из a в c. Общее время = d(b, a) + d(a, c).

    # Поскольку граф неориентированный, кратчайшее расстояние d(u, v) = d(v, u).
    # Чтобы получить эти кратчайшие расстояния, запускаем алгоритм Дейкстры трижды:
    # один раз из вершины a, один раз из b, и один раз из c.
    dist_a = dijkstra(a, n, adj) # dist_a[i] - d(a, i)
    dist_b = dijkstra(b, n, adj) # dist_b[i] - d(b, i)
    dist_c = dijkstra(c, n, adj) # dist_c[i] - d(c, i)

    # Вычисляем общее время для каждого из трех вариантов "покрытия", используя
    # полученные кратчайшие расстояния.
    # d(a, b) = dist_a[b]
    # d(b, c) = dist_b[c]
    # d(a, c) = dist_a[c]
    # d(c, b) = dist_c[b] (или dist_b[c], так как d(c, b) = d(b, c))
    # d(b, a) = dist_b[a] (или dist_a[b], так как d(b, a) = d(a, b))

    # Вариант 1: Путь, который покрывает кратчайшие пути a -> b и b -> c.
    option1_time = dist_a[b] + dist_b[c]

    # Вариант 2: Путь, который покрывает кратчайшие пути a -> c и c -> b.
    option2_time = dist_a[c] + dist_c[b]

    # Вариант 3: Путь, который покрывает кратчайшие пути b -> a и a -> c.
    option3_time = dist_b[a] + dist_a[c]

    # Минимальное время, чтобы посетить все три домика, - это минимум из времен этих трех вариантов.
    # Если какие-либо из расстояний d(a, b), d(b, c), d(a, c) бесконечны (например, вершины
    # находятся в разных компонентах связности), соответствующие суммы будут бесконечны.
    min_total_time = min(option1_time, option2_time, option3_time)

    # Если минимальное вычисленное время равно бесконечности, это означает, что
    # невозможно построить путь, который посещает все три домика (они не лежат в одной
    # компоненте связности). В этом случае по условию задачи выводим -1.
    if min_total_time == float('inf'):
        print(-1)
    else:
        # Иначе выводим минимальное найденное время.
        print(min_total_time)

# Запускаем главную функцию решения задачи.
solve()