# Адаптированная версия кода для решения "Задачи C. Печатная схема".
# Задача сводится к поиску минимального остовного дерева на сеточном графе.
# Некоторые ребра (перемычки) уже существуют. Необходимо добавить недостающие
# перемычки с минимальной общей стоимостью, чтобы граф стал связным.
# Вертикальные перемычки стоят 1, горизонтальные - 2.

from sys import stdin
# functools и cmp_to_key не нужны в адаптированном коде,
# так как сортировка выполняется с использованием lambda-функции.
# from functools import cmp_to_key

# Структура данных Disjoint Set Union (DSU) - Непересекающиеся Множества.
# Повторно используется из предоставленного кода.
# Позволяет эффективно определять принадлежность элементов к компонентам связности
# и объединять компоненты.
class DSU:
    def __init__(self, n):
        # parent[i] хранит родителя элемента i. Изначально каждый является своим родителем.
        self.parent = list(range(n))
        # rank[i] хранит ранг (или размер) дерева с корнем в элементе i. Используется для оптимизации объединения.
        self.rank = [1] * n
        # components хранит текущее количество непересекающихся множеств (компонент связности).
        self.components = n

    # Найти представителя (корень) множества, содержащего элемент i.
    # Использует сжатие путей для оптимизации.
    def find(self, i):
        if self.parent[i] != i:
            # Сжатие путей: установить родителя i сразу в корень.
            self.parent[i] = self.find(self.parent[i])
        return self.parent[i]

    # Объединить множества, содержащие элементы x и y.
    # Использует объединение по рангу (или размеру).
    def union(self, x, y):
        s1 = self.find(x)
        s2 = self.find(y)
        if s1 != s2: # Если они в разных множествах
            # Объединение по рангу: присоединить меньшее дерево к корню большего дерева.
            if self.rank[s1] < self.rank[s2]:
                self.parent[s1] = s2
            elif self.rank[s1] > self.rank[s2]:
                self.parent[s2] = s1
            else:
                # Если ранги равны, присоединить одно к другому и увеличить ранг корня.
                self.parent[s2] = s1
                self.rank[s1] += 1
            # Уменьшить количество компонент связности, так как два множества объединены.
            self.components -= 1

    # Проверить, связаны ли все элементы (граф является связным).
    def is_connected(self):
        # Если количество компонент связности 0 или 1, граф связен.
        return self.components <= 1

# Основная логика для решения задачи на сетке.
def solve():
    # Чтение размеров сетки (N - строк, M - столбцов)
    n, m = [int(x) for x in stdin.readline().split()]

    # Чтение описания начальных перемычек в виде сетки
    grid = []
    for _ in range(n):
        grid.append([int(x) for x in stdin.readline().split()])

    # Общее количество узлов (вершин) в графе
    num_vertices = n * m

    # Обработка крайних случаев для пустой сетки или сетки с одним узлом
    if num_vertices == 0 or num_vertices == 1:
         print("0 0")
         return

    # Инициализация DSU: каждый узел изначально является отдельной компонентой связности
    dsu = DSU(num_vertices)

    # Вспомогательная функция для преобразования 0-основанных координат сетки (строка r, столбец c)
    # в уникальный индекс вершины (от 0 до num_vertices - 1)
    def get_vertex_index(r, c):
        return r * m + c

    # 1. Обработка начальных перемычек: объединяем компоненты связности для уже существующих ребер.
    # Это эквивалентно рассмотрению их как ребер с нулевой стоимостью в алгоритме Краскала.
    # Перебираем каждую ячейку (r, c) сетки (0-основанная индексация)
    for r in range(n):
        for c in range(m):
            # Получаем тип соединения из входной сетки для узла (r, c)
            conn = grid[r][c]
            # Получаем индекс вершины для текущего узла (r, c)
            u = get_vertex_index(r, c)

            # Проверяем наличие существующей вертикальной перемычки вниз от (r, c) к (r+1, c)
            # Вертикальная перемычка возможна, если (r, c) не в последней строке
            if r < n - 1:
                 # Если 0-й бит установлен в conn (значение 1 или 3), есть вертикальная перемычка
                if (conn & 1):
                    # Получаем индекс вершины для узла снизу (r+1, c)
                    v = get_vertex_index(r + 1, c)
                    # Объединяем множества, содержащие два связанных узла
                    dsu.union(u, v)

            # Проверяем наличие существующей горизонтальной перемычки вправо от (r, c) к (r, c+1)
            # Горизонтальная перемычка возможна, если (r, c) не в последнем столбце
            if c < m - 1:
                # Если 1-й бит установлен в conn (значение 2 или 3), есть горизонтальная перемычка
                if (conn & 2):
                    # Получаем индекс вершины для узла справа (r, c+1)
                    v = get_vertex_index(r, c + 1)
                    # Объединяем множества, содержащие два связанных узла
                    dsu.union(u, v)

    # Если после обработки всех начальных перемычек граф уже связен,
    # добавление дополнительных перемычек не требуется.
    if dsu.is_connected():
         print("0 0")
         return

    # 2. Генерируем список потенциальных перемычек (кандидатов):
    # Это возможные перемычки (вертикальные или горизонтальные), которых нет изначально
    # согласно входной сетке. Нам нужно рассмотреть возможность их добавления
    # с указанными стоимостями (1 для вертикальной, 2 для горизонтальной)
    # для связывания компонент.
    candidate_edges = []
    # Перебираем каждую потенциальную "начальную" ячейку (r, c) для новой перемычки (0-основанная)
    for r in range(n):
        for c in range(m):
            # Получаем тип соединения из входной сетки для узла (r, c)
            conn = grid[r][c]
            # Получаем индекс вершины для текущего узла (r, c)
            u = get_vertex_index(r, c)

            # Рассматриваем потенциальную вертикальную перемычку вниз от (r, c) к (r+1, c)
            # Эта перемычка возможна только если (r, c) не в последней строке
            if r < n - 1:
                # Получаем индекс вершины для узла снизу (r+1, c)
                v = get_vertex_index(r + 1, c)
                # Проверяем, отсутствовала ли начальная вертикальная перемычка вниз от (r, c)
                # согласно значению в grid[r][c]. Если 0-й бит НЕ установлен.
                if not (conn & 1):
                    # Это перемычка-кандидат для добавления. Стоимость = 1.
                    # Сохраняем информацию о ребре: (вершина_u, вершина_v, стоимость, output_i, output_j, output_d)
                    # Вывод требует 1-основные координаты (i, j) начального узла и тип d.
                    # Узел (r, c) (0-основанный) соответствует 1-основному (r+1, c+1).
                    # Вертикальная перемычка (i, j) к (i+1, j) имеет тип d=1.
                    candidate_edges.append((u, v, 1, r + 1, c + 1, 1))

            # Рассматриваем потенциальную горизонтальную перемычку вправо от (r, c) к (r, c+1)
            # Эта перемычка возможна только если (r, c) не в последнем столбце
            if c < m - 1:
                # Получаем индекс вершины для узла справа (r, c+1)
                v = get_vertex_index(r, c + 1)
                 # Проверяем, отсутствовала ли начальная горизонтальная перемычка вправо от (r, c)
                 # согласно значению в grid[r][c]. Если 1-й бит НЕ установлен.
                if not (conn & 2):
                     # Это перемычка-кандидат для добавления. Стоимость = 2.
                     # Сохраняем информацию о ребре: (вершина_u, вершина_v, стоимость, output_i, output_j, output_d)
                     # Узел (r, c) (0-основанный) соответствует 1-основному (r+1, c+1).
                     # Горизонтальная перемычка (i, j) к (i, j+1) имеет тип d=2.
                    candidate_edges.append((u, v, 2, r + 1, c + 1, 2))

    # 3. Сортируем перемычки-кандидаты по их стоимости (весу) в порядке возрастания.
    # Это необходимо для алгоритма Краскала для поиска минимального остовного дерева.
    # Кандидаты - это кортежи (u, v, weight, out_r, out_c, out_d). Сортируем по 3-му элементу (weight).
    candidate_edges.sort(key=lambda x: x[2])

    # 4. Применяем алгоритм Краскала к отсортированным перемычкам-кандидатам для связывания компонент.
    # Перебираем перемычки-кандидаты и добавляем их, если они соединяют две разные компоненты,
    # пока граф не станет полностью связным.
    added_cost = 0 # Общая стоимость добавленных перемычек
    added_edges_list = [] # Список для хранения деталей добавленных перемычек для вывода

    # Перебираем отсортированные по стоимости перемычки-кандидаты
    for u, v, weight, out_r, out_c, out_d in candidate_edges:
        # Проверяем, находятся ли узлы u и v уже в одной компоненте связности
        # (либо благодаря начальным перемычкам, либо благодаря ранее добавленным перемычкам-кандидатам)
        if dsu.find(u) != dsu.find(v):
            # Если они в разных компонентах, добавление этой перемычки свяжет их.
            # Добавляем перемычку к нашему минимальному набору добавляемых перемычек.
            dsu.union(u, v) # Объединяем две компоненты
            added_cost += weight # Добавляем стоимость этой перемычки к общей стоимости
            added_edges_list.append((out_r, out_c, out_d)) # Записываем перемычку для последующего вывода

            # Оптимизация: Если количество компонент связности стало равно 1,
            # граф полностью связен. Мы нашли минимальное остовное дерево
            # из недостающих ребер, необходимое для связывания графа.
            # Можно прекратить обработку оставшихся перемычек.
            if dsu.is_connected():
                break # Выходим из цикла досрочно

    # 5. Выводим результаты согласно указанному формату.
    # Первая строка: количество добавленных перемычек (K) и общая стоимость добавления (V)
    print(len(added_edges_list), added_cost)
    # Следующие K строк: описание каждой добавленной перемычки в формате i, j, d
    for edge in added_edges_list:
        # Выводим элементы кортежа через пробел
        print(*edge)

# Выполнение основной функции решения задачи
solve()