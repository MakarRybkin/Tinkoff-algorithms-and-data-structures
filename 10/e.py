# Импорт необходимых модулей: sys для оптимизированного ввода/вывода и heapq для реализации приоритетной очереди.
import sys
import heapq


# Закомментированная строка для увеличения лимита рекурсии. В данном случае алгоритм Дейкстры итеративный,
# поэтому это не требуется, но может быть полезно для других задач с рекурсивными решениями.
# sys.setrecursionlimit(2000)

# Определяем основную функцию solve(), которая реализует логику алгоритма поиска кратчайших путей.
def solve():
    # Читаем первую строку входных данных, которая содержит два целых числа:
    # n - количество вершин в графе, и m - количество ребер.
    n, m = map(int, sys.stdin.readline().split())

    # Создаем список списков (список смежности) для представления графа.
    # adj - это список списков, где adj[i] является списком соседей вершины i.
    # Каждый элемент в списке соседей - это кортеж (j, weight), означающий, что вершина i
    # соединена с вершиной j ребром весом weight.
    # Используется 0-базовая индексация для вершин (от 0 до n-1).
    adj = [[] for _ in range(n)]

    # Читаем описания ребер. Каждое ребро задается начальной вершиной (u), конечной вершиной (v)
    # и весом (w).
    for _ in range(m):
        u, v, w = map(int, sys.stdin.readline().split())
        # Преобразование 1-базовой индексации вершин (из входных данных) в 0-базовую.
        u -= 1
        v -= 1
        # Поскольку граф неориентированный, добавляем информацию о ребре в списки смежности обеих вершин.
        adj[u].append((v, w))
        adj[v].append((u, w))

    # Инициализация списка dist для хранения кратчайших расстояний от стартовой вершины
    # до всех остальных вершин. Размер списка равен n.
    # Изначально все расстояния инициализируются как бесконечность, кроме расстояния до самой стартовой вершины.
    dist = [float('inf')] * n

    # Стартовая вершина по условию задачи - вершина 1. В нашей 0-базовой индексации это
    # соответствует индексу 0. Расстояние от стартовой вершины до самой себя равно 0.
    start_node_index = 0  # Индекс стартовой вершины (вершина 1)
    dist[start_node_index] = 0

    # Создаем приоритетную очередь (минимальную кучу) с использованием модуля heapq.
    # Приоритетная очередь хранит кортежи (текущее_кратчайшее_расстояние_до_вершины, индекс_вершины).
    # heapq автоматически упорядочивает элементы по первому элементу кортежа (расстоянию),
    # извлекая наименьший.
    pq = [(0, start_node_index)]  # Добавляем стартовую вершину в очередь с расстоянием 0

    # Главный цикл алгоритма Дейкстры. Выполняется до тех пор, пока приоритетная очередь не опустеет.
    while pq:
        # Извлекаем из приоритетной очереди кортеж с наименьшим текущим расстоянием.
        # heapq.heappop(pq) извлекает и возвращает элемент с наименьшим значением.
        d, u = heapq.heappop(pq)  # d - текущее расстояние до вершины u, u - индекс вершины

        # Проверяем на "устаревшие" записи в очереди. Если расстояние d, с которым мы извлекли
        # вершину u из очереди, больше, чем текущее кратчайшее расстояние до u, записанное в dist[u],
        # это означает, что мы уже нашли более короткий путь к вершине u ранее и обновили dist[u].
        # Эту устаревшую запись можно проигнорировать.
        if d > dist[u]:
            continue

        # Итерация по всем соседям v вершины u с весом ребра w.
        for v, w in adj[u]:
            # Операция релаксации ребра (u, v).
            # Проверяем, можно ли улучшить кратчайшее расстояние до вершины v, пройдя через вершину u.
            # Расстояние до v через u будет равно текущему кратчайшему расстоянию до u (dist[u]) плюс вес ребра (u, v) (w).
            if dist[u] + w < dist[v]:
                # Если dist[u] + w меньше текущего кратчайшего расстояния до v (dist[v]),
                # это означает, что мы нашли более короткий путь до v.

                # Обновляем кратчайшее расстояние до вершины v.
                dist[v] = dist[u] + w
                # Добавляем вершину v в приоритетную очередь с новым, уменьшенным расстоянием.
                # heapq.heappush добавит новый кортеж (dist[v], v) в кучу.
                # Если вершина v уже была в очереди с большим расстоянием, эта новая запись
                # будет обработана раньше из-за меньшего расстояния.
                heapq.heappush(pq, (dist[v], v))

    # После завершения цикла (когда приоритетная очередь опустеет), список dist будет содержать
    # кратчайшие расстояния от стартовой вершины (индекс 0, вершина 1) до всех остальных вершин.
    # Выводим эти расстояния. Оператор *dist "распаковывает" элементы списка dist,
    # передавая их как отдельные аргументы в функцию print, которые по умолчанию разделяются пробелами.
    print(*dist)


# Вызываем функцию solve() для запуска выполнения программы.
solve()