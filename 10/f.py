import sys
import heapq

# Максимально допустимое время в пути в минутах. 24 часа * 60 минут/час = 1440 минут.
MAX_TIME = 24 * 60

# Вес пустого грузовика в граммах. 3 тонны = 3000 кг = 3000 * 1000 = 3,000,000 грамм.
EMPTY_TRUCK_WEIGHT = 3 * 1000 * 1000

# Вес одной кружки в граммах.
MUG_WEIGHT = 100


# Функция is_feasible(num_mugs, n, adj) проверяет, возможно ли перевезти
# заданное количество кружек (num_mugs) из стартовой вершины (1) в конечную (N)
# в пределах максимально допустимого времени (MAX_TIME), соблюдая при этом
# ограничения по весу на дорогах.
# n: количество вершин в графе.
# adj: список смежности графа.
def is_feasible(num_mugs, n, adj):
    """
    Проверяет, возможно ли перевезти num_mugs кружек из вершины 1 в вершину N
    в пределах MAX_TIME, соблюдая ограничения по весу.
    Возвращает True, если это возможно, False в противном случае.
    """
    # Вычисляем общий вес грузовика, включая вес пустой машины и вес всех кружек.
    current_weight = EMPTY_TRUCK_WEIGHT + num_mugs * MUG_WEIGHT

    # --- Реализация алгоритма Дейкстры для поиска кратчайшего пути ---
    # Этот алгоритм будет работать только с теми ребрами, по которым разрешено
    # проехать грузовику с текущим весом.

    # Инициализация списка расстояний (в данном случае, времени). dist[i] будет хранить
    # минимальное время, необходимое для достижения вершины с индексом i (от 0 до n-1)
    # из стартовой вершины (с индексом 0).
    # Изначально все расстояния устанавливаются в "бесконечность". Расстояние до стартовой
    # вершины самой от себя равно 0. Используем float('inf') для представления бесконечности.
    dist = [float('inf')] * n
    start_node_index = 0  # Индекс стартовой вершины (соответствует вершине 1 во входных данных).
    dist[start_node_index] = 0

    # Создаем приоритетную очередь (минимальную кучу) с использованием модуля heapq.
    # В этой очереди будут храниться кортежи вида (текущее_минимальное_время_до_вершины, индекс_вершины).
    # heapq реализует минимальную кучу, что означает, что функция heappop() всегда
    # извлекает элемент с наименьшим первым значением (наименьшим временем).
    pq = [(0, start_node_index)]  # Добавляем стартовую вершину в очередь с расстоянием 0.

    # Главный цикл алгоритма Дейкстры. Продолжаем работу, пока приоритетная очередь не пуста.
    while pq:
        # Извлекаем вершину u с наименьшим текущим временем d из приоритетной очереди.
        # heapq.heappop(pq) извлекает и возвращает элемент с наименьшим значением.
        d, u = heapq.heappop(pq)  # d - время до вершины u, u - индекс вершины

        # Проверяем на "устаревшие" записи в очереди. Если извлеченное время d больше,
        # чем текущее наилучшее время, уже записанное для вершины u в dist[u], это означает,
        # что мы уже нашли более короткий путь к u ранее. Эта запись в очереди устарела,
        # и мы ее игнорируем.
        if d > dist[u]:
            continue

        # Итерируемся по всем соседям вершины u. Список смежности adj[u] содержит кортежи
        # (v, travel_time, weight_limit), где v - индекс соседней вершины,
        # travel_time - время в пути по ребру (u, v), weight_limit - ограничение веса на этом ребре.
        for v, travel_time, weight_limit in adj[u]:
            # Прежде чем рассматривать это ребро, проверяем, разрешено ли по нему проехать
            # грузовику с текущим весом (current_weight). Условие: общий вес грузовика
            # не должен превышать ограничение на дороге.
            if current_weight <= weight_limit:
                # Если дорога разрешена, проверяем, можно ли улучшить кратчайшее время до соседа v.
                # dist[u] + travel_time - это время в пути до вершины v, если идти из стартовой
                # вершины через вершину u.
                if dist[u] + travel_time < dist[v]:
                    # Если найдено более короткое время до вершины v, обновляем его в списке dist.
                    dist[v] = dist[u] + travel_time
                    # Добавляем вершину v в приоритетную очередь с новым, меньшим временем.
                    # heapq.heappush(pq, (dist[v], v)) добавит новый элемент в кучу.
                    # Если вершина v уже была в очереди с большим расстоянием, эта новая запись
                    # будет обработана раньше из-за меньшего расстояния.
                    heapq.heappush(pq, (dist[v], v))

    # --- Конец алгоритма Дейкстры ---

    # После завершения алгоритма Дейкстры, dist[n-1] будет содержать минимальное время
    # для достижения конечной вершины (с индексом n-1, соответствует вершине N)
    # по всем разрешенным дорогам.
    # Функция возвращает True, если это время меньше или равно максимально допустимому времени (MAX_TIME),
    # что означает, что заданное количество кружек перевезти возможно в срок. В противном случае возвращает False.
    return dist[n - 1] <= MAX_TIME


# Определяем основную функцию solve(), которая координирует процесс поиска максимального количества кружек.
def solve():
    # Читаем количество вершин (N) и количество ребер (M) из стандартного ввода.
    n, m = map(int, sys.stdin.readline().split())

    # Создаем список смежности графа. adj[i] - список кортежей (сосед_индекс, время_в_пути, ограничение_веса).
    # Используем 0-базовую индексацию вершин (от 0 до n-1) для удобства работы со списками в Python.
    adj = [[] for _ in range(n)]

    # Читаем информацию о M дорогах (ребрах). Каждая строка описывает одно ребро.
    for _ in range(m):
        u, v, time, weight_limit = map(int, sys.stdin.readline().split())
        # Преобразуем 1-базовые номера вершин (u, v) из входных данных в 0-базовые индексы.
        u -= 1
        v -= 1
        # Поскольку граф неориентированный, добавляем информацию о ребре в списки смежности обеих вершин.
        # Сохраняем индекс соседа, время в пути по ребру и ограничение веса на этом ребре.
        adj[u].append((v, time, weight_limit))
        adj[v].append((u, time, weight_limit))

    # Используем бинарный поиск для нахождения максимального количества кружек.
    # Мы ищем максимальное количество кружек, которое можно перевезти в срок.
    # Свойство монотонности: если можно перевезти X кружек в срок, то можно перевезти и X-1 кружек (или меньше).
    # Если нельзя перевезти X кружек, то нельзя перевезти и X+1 кружек (или больше).
    # Диапазон поиска для количества кружек: от 0 до 10,000,000 (по условию задачи).
    low = 0  # Минимальное возможное количество кружек.
    high = 10000000  # Максимальное возможное количество кружек (заказ на 10 млн).
    ans_mugs = 0  # Переменная для хранения максимального количества кружек, которое удалось перевезти в срок. Инициализируем нулем.

    # Выполняем бинарный поиск. Цикл продолжается, пока нижняя граница не превысит верхнюю.
    while low <= high:
        # Вычисляем среднее значение количества кружек в текущем диапазоне поиска.
        mid_mugs = (low + high) // 2

        # Проверяем, является ли количество mid_mugs кружек возможным для перевозки в срок.
        # Вызываем функцию is_feasible, которая использует алгоритм Дейкстры.
        if is_feasible(mid_mugs, n, adj):
            # Если с mid_mugs кружками уложиться в срок возможно:
            # 1. mid_mugs - это потенциальный ответ или лучший из найденных на данный момент.
            # 2. Попробуем перевезти еще больше кружек. Сдвигаем нижнюю границу,
            #    чтобы искать в правой части диапазона (включая mid_mugs как возможный ответ).
            ans_mugs = mid_mugs  # Сохраняем текущее возможное количество кружек как лучший найденный ответ.
            low = mid_mugs + 1  # Ищем больше кружек в диапазоне [mid_mugs + 1, high].
        else:
            # Если с mid_mugs кружками уложиться в срок НЕвозможно:
            # Значит, mid_mugs кружек - слишком много (из-за ограничений по весу, которые заставляют
            # выбирать более долгие пути, превышающие MAX_TIME).
            # Нужно уменьшить количество кружек. Сдвигаем верхнюю границу, чтобы искать в левой части диапазона.
            high = mid_mugs - 1  # Ищем ответ в диапазоне [low, mid_mugs - 1].

    # После завершения бинарного поиска, переменная ans_mugs будет содержать максимальное количество кружек,
    # для которого функция is_feasible вернула True. Это и есть максимальное количество кружек, которое можно
    # перевезти в срок, соблюдая ограничения по весу.
    print(ans_mugs)


# Вызываем функцию solve() для начала выполнения программы.
solve()
